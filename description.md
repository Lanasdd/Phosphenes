# Phosphenes
## Для чего
Бот создан для помощи в организации тренировочного и соревновательного процесса волейбольных команд г. Архангельска. Т.к. я являюсь игроком одной из таких команд, которая надеется на победу в предстоящем чемпионате г. Архангельска, то решено было совместить необходимость создания бота с востребованной функциональностью.

## Для кого
1. Прежде всего для тренерского штаба и игроков волейбольных команд Каравелла 1 и Каравелла 2.
2. Для игроков остальных команд, принимающих участие в соревнованиях по волейболу в г. Архангельске и Архангельской области.
3. Для болельщиков указанных команд.
   
## Сторонние библиотеки
1. ***sqlite3***: модуль для работы с базами данных SQLite. Используется для хранения основных конфигурационных файлов. В последующем будет также использоваться для хранения персистентного состояния между перезапусками бота.
2. ***telebot***: модуль для работы с Telegram Bot API.
3. ***schedule***: модуль для планирования выполнения задач в определенное время. В данном коде используется для создания расписания отправки сообщений пользователю.
4. ***threading***: модуль для работы с потоками ОС. В данном коде используется для выполнения планового задания.
5. ***requests***: модуль для отправки HTTP-запросов. В данном коде используется для отправки GET-запроса к API погоды и получения данных о погоде.
6. ***os***: модуль, предоставляющий портативный способ использования функций, зависящих от операционной системы. Используется для получения данных из переменных окружения ОС.
7. ***sys***: модуль обеспечивающий доступ к некоторым переменным, используемым или поддерживаемым интерпретатором, а также к функциям, которые тесно взаимодействуют с интерпретатором. Используется для доступа к параметрам командной строки.
8. ***getopt***: модуль, позволяющий анализировать аргументы командной строки, поддерживает Unix соглашения. Используется для разбора командной строки для получения конфигурационных параметров запущенного экземпляра бота.  

## Первоначальное конфигурирование и запуск
Т.к. бот реализован в виде скрипта python, то на хосте запуска должна быть развёрнута инфраструктура python, установлены сторонние модули, предоставлен доступ по протоколу https до api telegram и api openweather.

Порядок запуска:
1. Разместить на хосте в директории запуска скрипт бота и базу данных 
volley_bot.db.
2. В БД выполнить конфигурацию таблиц users, teams, schedule. Заполнение таблицы users влияет на доступ к функциям бота.
3. Для запуска боту необходимо передать token и идентификатор пользователя, выступающего в качестве администратора данных. Это можно сделать либо заполнив системные переменные окружения VOLLEY_BOT_TOKEN и VOLLEY_BOT_ADMIN, либо передав их скрипту в качестве параметров запуска –-bot_token и –-admin_id, например, так:
   
`<...>.py --bot_token <TOKEN> --admin_id <ADMIN_TELEGRAM_ID>`

## Функционал

### Кратко
1. Выдача пользователю актуального расписания тренировок в зависимости от дня недели по запросу.
2. Выдача пользователю информации об играх предстоящего чемпионата г. Архангельска по запросу.
3. Рассылка важных событий или изменений в расписании. В том числе рассылка сообщений в определенное время для напоминания о приближающейся тренировке, а также напоминания о том, что необходимо пройти опрос, то есть указать, идешь ли ты на тренировку, что является удобной и полезной функцией для тренера, который сможет заранее создать план тренировки.
4. Организация опроса среди членов команды для получения актуальной информации о составе команды на предстоящую тренировку или игру.
5. Предоставление сводной текущей информации ограниченному числу пользователей (тренеры и игроки) о составе команды на предстоящую тренировку или игру.
6. Выдача пользователю информации о погоде в запрашиваемом городе по запросу, что особенно важно для сезона пляжного волейбола.

### О рассылке
Для рассылки существует команда 'total-results', вызвав которую будет выполняться функция 'total_results'. 
Если для id пользователя, отправившего команду, разрешено данное действие (т.е. он является администратором данных), то всем актуальным пользователям отправляется сообщение, указанное после команды '\send_all'.
Когда сообщение отправится всем пользователям, то админу придет сообщение: 'Сообщение отправлено всем пользователям.', указывая, что сообщение было отправлено всем пользователям.

Если id пользователя, отправившего команду, не совпадает с admin_id, это означает, что у пользователя нет прав на использование данной команды. В этом случае бот отправляет ответ на исходное сообщение: 'У вас нет доступа к этой команде.' указывая, что у пользователя нет доступа к этой команде.

Данная команда и функция необходимы для возможности отправки участникам команды объявлений и каких-либо изменений.

### О напоминаниях
Отправка сообщений по расписанию с использованием библиотеки schedule, планирование выполнения функции *send_scheduled_message*.
Она отправляет предопределённое сообщение особому списку пользователей, внесенных в таблицу базы данных.
Планирование запуска функции *send_scheduled_message* в определенные дни и время происходит с помощью следующего шаблонного функционала `<schedule.every().day.at('time').do(function)>`. В моем случае выполнение функции запланировано по средам в 10:00, пятницам в 10:00 и воскресеньям в 10:00.
функция *schedule_messages* постоянно проверяет наличие ожидающих запланированных задач и запускает их с помощью *schedule.run_pending*. Между проверками она засыпает на секунду с помощью функции *time.sleep(1)*

Эта функция необходима для оповещения участников команды о необходимости участия в голосовании о посещаемости тренировки, также о приближающейся тренировке.

### О голосовании
В главном меню пользователь может нажать на кнопку "**Голосование**", тем самым сообщив, будет ли он присутствовать на тренировке. О том, что пользователю необходимо принять участие в голосовании, напомнит функция *send_scheduled_message*.
Выбрав кнопку "**Голосование**", пользователь должен выбрать опцию ("**Буду**" или "**Не буду**"), соответствующую тому, пойдет он на тренировку или нет. Если текст сообщения пользователя равен "**Буду**" или "**Не буду**", то будет вызываться функция *record_vote_for_going*. Затем извлекается идентификатор пользователя, отправившего сообщение. Проверяется, разрешено ли данному пользователю это действие. Если пользователь разрешено, то его выбор ("**Буду**" или "**Не буду**") записывается в актуальное хранилище экземпляра бота под ключом 'user_id'. На текущий момент это *_voting_results* в объекте класса *BotStorage*.

Бот отправляет сообщение пользователю с текстом *"Your answer is recorded. Click the button 'Return to the main menu'"* для информирования пользователя о том, что его ответ записан.
При необходимости, пользователь может изменить свой выбор.

Если пользователь не разрешено данное действие, бот отправляет сообщение с текстом *"Sorry, you are not allowed to vote"*, сообщая пользователю, что ему не разрешено голосовать.

Для просмотра результатов голосования существует команда *total_results*, вызвав которую, будет выполняться функция *total_results*.
Проверяется, есть ли пользователь, отправивший команду, в числе разрешенных пользователей. Если нет, то отправляется ответное сообщение о том, что пользователь не имеет права просматривать результаты.
*user_names_with_vote1* и *user_names_with_vote2* - два списка, которые будут использоваться для хранения имен пользователей, проголосовавших "**Буду**" и "**Не буду**" соответственно.
Код проверяет голос пользователя и добавляет его имя либо к *user_names_with_vote1*, либо к *user_names_with_vote2* в зависимости от его выбора.
После обработки всех пользователей код формирует итоговое сообщение с именами пользователей, проголосовавших отдельно "**Буду**" и "**Не буду**".
Наконец, в качестве ответа пользователю, подавшему команду /total_results, отправляется (посредством `send_message(message.chat.id, result_message)`) сообщение с результатом, в котором отображаются имена пользователей, проголосовавших "**Буду**" и "**Не буду**".

Это необходимо для контроля посещаемости, также на основе данного голосования тренер сможет заранее составить план тренировки.

### Сброс результатов голосования
Определяется список, содержащий номера дней недели, в которые необходимо сбросить результаты голосования. В моем коде это понедельник (0), среда (3) и пятница (5).
Для получения текущей даты и времени используется функционал *'datetime.datetime.now()'*.
Проверяется, есть ли текущий день, заданный *now.weekday()*, в списке. Если да, то происходит сброс результатов голосования.

### О прогнозе погоды
Если пользователь выбрал кнопку прогноз погоды, то бот отправит ему сообщение:
'Отправьте боту название города и он скажет, какая там погода'

После указания пользователем города, бот формирует запрос:
*url = 'https://api.openweathermap.org/data/2.5/weather?q='+city+'&units=metric&lang=ru&appid= API-токен '*

Отправляет запрос на сервер и сразу получает результат.
Затем происходит парсинг ответа OpenWeather в формате JSON: заберем данные о городе и температуре, влажности, скорости ветра, восходе, заходе.

Декорируем сообщения, выводим сообщение пользователю.

Возможность посмотреть погоду необходима в сезон пляжного волейбола.

